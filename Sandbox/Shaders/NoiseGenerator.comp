#pragma kernel GenerateNoise2D
#pragma kernel GenerateNoise3D

#pragma kernel GenerateNoise2DMultiLayer
#pragma kernel GenerateNoise3DMultiLayer

#version 460 core 

/**************** Uniforms *********************/
layout(rgba8, binding = 0) uniform image2D _NoiseTex2D;
layout(rgba8, binding = 1) uniform image3D _NoiseTex3D;

struct NoiseLayer {
	int type;
	int blend;
	vec3 offset;
	int octaveCount ;
	int scale;
	float normalizedScale;
	float opacity;
	float coverage;
	int smoothnessLevel;
};

uniform bool _NoiseRepeatEnabled;
uniform ivec3 _RepeatFrequency;
uniform ivec3 _RepeatOffset;

//Single Layer
uniform NoiseLayer _Layer;

//Multi Layer
uniform NoiseLayer _Layers[10];
uniform uint _LayerCount;

uniform uvec3 _TexSize;
uniform bool _WriteTo2DTex;

uniform uint _ChannelIndex;
////////////////////////////////////////////////

/* Constants and functions below are used to convert signed and unsigned integers to
		32 bit and 64 bit floating points, range[0,1)
		https://www.doornik.com/research/randomdouble.pdf
*/

#ifndef M_RAN_INVM32
#define M_RAN_INVM32 2.32830643653869628906e-010
#endif 

#ifndef PI
#define PI 3.1415926535897
#endif

//uint to float converter
float Ran32Flt1(uint uiRan) {
	return float(int(uiRan) * M_RAN_INVM32 + 0.5);
}


//https://www.researchgate.net/publication/5142825_Xorshift_RNGs
uint xorshift64_uint(uint x, uint y) {
	//[8, 9, 22]
	uint t = x ^ (x << 8);
	x = y;

	y = (y ^ (y >> 22)) ^ (t ^ (t >> 9));

	return y;
}

int xorshift64_int(uint x, uint y) {
	return int(xorshift64_uint(x, y));
}

float xorshift64_float(uint x, uint y) {
	return Ran32Flt1(xorshift64_uint(x,y));
}

uint xorshift96_uint(uint x, uint y, uint z) {
	//[13, 19, 3]
	uint t = x ^ (x << 13);
	x = y;
	y = z;

	z = (z ^ (z >> 3)) ^ (t ^ (t >> 19));

	return z;
}

int xorshift96_int(uint x, uint y, uint z) {
	return int(xorshift96_uint(x, y, z));
}

float xorshift96_float(uint x, uint y, uint z) {
	return Ran32Flt1(xorshift96_uint(x, y, z));
}


/////////////////////////////////////////////////////////////

ivec2 getFrequencyBasedCoordinate(int x, int y) {
	int fx = x;
	int fy = y;

	if (_NoiseRepeatEnabled) {
		int intPart = int(x / _RepeatFrequency.x);
		fx = x - intPart * _RepeatFrequency.x + _RepeatOffset.x;

		intPart = int(y / _RepeatFrequency.y);
		fy = y - intPart * _RepeatFrequency.y + _RepeatOffset.y;
	}

	return ivec2(fx, fy);
}

ivec3 getFrequencyBasedCoordinate(int x, int y, int z) {
	int fx = x;
	int fy = y;
	int fz = z;

	if (_NoiseRepeatEnabled) {
		int intPart = int(x / _RepeatFrequency.x);
		fx = x - intPart * _RepeatFrequency.x + _RepeatOffset.x;

		intPart = int(y / _RepeatFrequency.y);
		fy = y - intPart * _RepeatFrequency.y + _RepeatOffset.y;

		intPart = int(z / _RepeatFrequency.z);
		fz = z - intPart * _RepeatFrequency.z + _RepeatOffset.z;
	}

	return ivec3(fx, fy, fz);
}

float remap(float originalValue, float originalMin, float originalMax, float newMin, float newMax) {
	return newMin + (originalValue - originalMin) / (originalMax - originalMin) * (newMax - newMin);
}

//////////////////////////////////////////////////////////////

vec2 randomPoint(int x, int y) {
	ivec2 fpos = getFrequencyBasedCoordinate(x, y);

	uint seed = (fpos.x + 7) * (fpos.y + 19) + 48271; 
	uint ux = 181243323U * (seed ^ (seed >> 30)) + 1;
	uint uy = 181243323U * (ux ^ (ux >> 30)) + 2;

	uint rseed = xorshift64_uint(ux, uy); 

	return vec2(Ran32Flt1(rseed), xorshift64_float(uy, rseed));
}

vec3 randomPoint(int x, int y, int z) {
	ivec3 fpos = getFrequencyBasedCoordinate(x, y, z);

	uint seed = (fpos.x + 7) * (fpos.y + 19) * (fpos.z + 49) + 48271; 
	uint ux = 181243323U * (seed ^ (seed >> 30)) + 1;
	uint uy = 181243323U * (ux ^ (ux >> 30)) + 2;
	uint uz = 181243323U * (uy ^ (uy >> 30)) + 3;

	uint rseed = xorshift96_uint(ux, uy, uz); 
	uint rseed2 = xorshift96_uint(fpos.y, fpos.z, rseed);

	float xf = Ran32Flt1(rseed);
	float yf = Ran32Flt1(rseed2);
	float zf = xorshift96_float(fpos.z, rseed, rseed2);

	return vec3(xf, yf, zf);
}

vec2 randomVector(int x, int y) {
	ivec2 fpos = getFrequencyBasedCoordinate(x, y);

	uint seed = (fpos.x + 7) * (fpos.y + 19) * 48271 + 37; 
	uint ux = 181243323U * (seed ^ (seed >> 30)) + 1;
	uint uy = 181243323U * (ux ^ (ux >> 30)) + 2;

	float random = xorshift64_float(ux, uy);

	return vec2(cos(random * PI * 2.0f), sin(random * PI * 2.0f));
}

vec3 randomVector(int x, int y, int z) {
	ivec3 fpos = getFrequencyBasedCoordinate(x, y, z);

	uint seed = (fpos.x + 7) * (fpos.y + 19) * (fpos.z + 49) + 48271; 
	uint ux = 181243323U * (seed ^ (seed >> 30)) + 1;
	uint uy = 181243323U * (ux ^ (ux >> 30)) + 2;
	uint uz = 181243323U * (uy ^ (uy >> 30)) + 3;

	uint rseed = xorshift96_uint(ux, uy, uz); 

	float r1 = Ran32Flt1(rseed);
	float r2 = xorshift96_float(uy, uz, rseed);

	vec3 nvector; //Normalized vector
	nvector.x = cos(PI * r1 * 2.0f) * sin(PI * r2 * 2.0f);
	nvector.y = cos(PI * r2);			  
	nvector.z = sin(PI * r1 * 2.0f) * sin(PI * r2 * 2.0f);

	return nvector;
}

////////////////////////////////////////////////////////////////////

float dotGridGradient(int ix, int iy, float x, float y) {
	vec2 gradient = randomVector(ix, iy);

	vec2 dist = vec2(x - ix , y - iy);
	return dot(gradient, dist);
}

float dotGridGradient(int ix, int iy, int iz, float x, float y, float z) {
	vec3 gradient = randomVector(ix, iy, iz);
	vec3 dist = vec3(x - ix, y - iy, z - iz);

	return dot(gradient, dist);
}

float interpolate(float a0, float a1, float w, int smoothness) {
	if (w < 0) w = 0;
	else if (w > 1.0f) w = 1.0f;

	switch (smoothness) {
	case 0:
		return (a1 - a0) * w + a0;
		break;
	case 1:
		return (a1 - a0) * (3.0f - w * 2.0f) * w * w + a0;
		break;
	case 2:
		return (a1 - a0) * ((w * (w * 6.0f - 15.0f) + 10.0f) * w * w * w) + a0;
		break;
	default:
		return (a1 - a0) * ((w * (w * 6.0 - 15.0f) + 10.0f) * w * w * w) + a0;
		break;
	}

	return 0;
}

////////////////////////////////////////////////////////////////////////////

float Perlin2D(float x, float y, int smoothnessLevel) {

	int x0 = int(x);
	int x1 = int(x + 1);
	int y0 = int(y);
	int y1 = int(y0 + 1);

	float sx = x - float(x0);
	float sy = y - float(y0);

	float n0, n1, n2, n3, ix0, ix1, value;

	n0 = dotGridGradient(x0, y0, x, y);
	n1 = dotGridGradient(x1, y0, x, y);
	ix0 = interpolate(n0, n1, sx, smoothnessLevel);

	n2 = dotGridGradient(x0, y1, x, y);
	n3 = dotGridGradient(x1, y1, x, y);
	ix1 = interpolate(n2, n3, sx, smoothnessLevel);

	value = interpolate(ix0, ix1, sy, smoothnessLevel);

	return clamp(value + 0.5f, 0, 1);
}

float Perlin3D(float x, float y, float z, int smoothnessLevel) {
	int x0 = int(x);
	int x1 = int(x + 1);
	int y0 = int(y);
	int y1 = int(y0 + 1);
	int z0 = int(z);
	int z1 = int(z0 + 1);

	float sx = x - float(x0);
	float sy = y - float(y0);
	float sz = z - float(z0);

	float n0, n1, n2, n3, ix0, ix1, iy0, iy1, value;

	n0 = dotGridGradient(x0, y0, z0, x, y, z);
	n1 = dotGridGradient(x1, y0, z0, x, y, z);
	ix0 = interpolate(n0, n1, sx, smoothnessLevel);

	n2 = dotGridGradient(x0, y1, z0, x, y, z);
	n3 = dotGridGradient(x1, y1, z0, x, y, z);
	ix1 = interpolate(n2, n3, sx, smoothnessLevel);

	iy0 = interpolate(ix0, ix1, sy, smoothnessLevel);

	n0 = dotGridGradient(x0, y0, z1, x, y, z);
	n1 = dotGridGradient(x1, y0, z1, x, y, z);
	ix0 = interpolate(n0, n1, sx, smoothnessLevel);

	n2 = dotGridGradient(x0, y1, z1, x, y, z);
	n3 = dotGridGradient(x1, y1, z1, x, y, z);
	ix1 = interpolate(n2, n3, sx, smoothnessLevel);

	iy1 = interpolate(ix0, ix1, sy, smoothnessLevel);

	value = interpolate(iy0, iy1, sz, smoothnessLevel);

	return clamp(value + 0.5f, 0, 1);
}

float Worley2D(float x, float y, int smoothnessLevel, bool inverse = false) {
	vec2 origin = vec2(x, y);

	int x0 = int(x);
	int y0 = int(y);

	float minDistance = 1;

	for (int y1 = -1; y1 <= 1; y1++) {
		for (int x1 = -1; x1 <= 1; x1++) {
			vec2 point = vec2(x0 + x1, y0 + y1) + randomPoint(x0 + x1, y0 + y1);
			float distance = length(point - origin);

			if (minDistance > distance)
				minDistance = distance;
		}
	}

	float noise = interpolate(0, 1, minDistance, smoothnessLevel);;

	if (inverse)
		noise = 1.0f - noise;

	return noise;
}

float Worley3D(float x, float y, float z, int smoothnessLevel, bool inverse = false) {
	vec3 origin = vec3(x, y, z);

	int x0 = int(x);
	int y0 = int(y);
	int z0 = int(z);

	float minDistance = 1;

	for (int z1 = -1; z1 <= 1; z1++) {
		for (int y1 = -1; y1 <= 1; y1++) {
			for (int x1 = -1; x1 <= 1; x1++) {
				vec3 point = vec3(x0 + x1, y0 + y1, z0 + z1) + randomPoint(x0 + x1, y0 + y1, z0 + z1);
				float distance = length(point - origin);

				if (minDistance > distance)
					minDistance = distance;
			}
		}
	}

	float noise = interpolate(0, 1, minDistance, smoothnessLevel);

	if (inverse)
		noise = 1.0f - noise;

	return noise;
}

float Value(vec3 point, NoiseLayer layer) {
	float noise = 0;
	float totalOctaveStrength = 0;

	for (int i = 0; i < layer.octaveCount; i++) {
		float octaveStrength = 1.0f / (pow(2.0f, i + 1.0f)); //1.0, 0.5, 0.25, 0.125,...

		vec3 position =  (point * layer.normalizedScale + layer.offset) / octaveStrength;

		switch (layer.type) {
		case 0:
			noise += Perlin2D(position.x, position.y, layer.smoothnessLevel) * octaveStrength;
			break;
		case 1:
			noise += Perlin3D(position.x, position.y, position.z, layer.smoothnessLevel) * octaveStrength;
			break;
		case 2:
			noise += Worley2D(position.x, position.y, layer.smoothnessLevel, false) * octaveStrength;
			break;
		case 3:
			noise += Worley3D(position.x, position.y, position.z, layer.smoothnessLevel, false) * octaveStrength;
			break;
		case 4:
			noise += Worley2D(position.x, position.y, layer.smoothnessLevel, true) * octaveStrength;
			break;
		case 5:
			noise += Worley3D(position.x, position.y, position.z, layer.smoothnessLevel, true) * octaveStrength;
			break;
		}

		totalOctaveStrength += octaveStrength;
	}

	noise = remap(noise, 0, totalOctaveStrength, 0, 1); 
	noise = clamp(noise, 1.0f - layer.coverage, 1);

	return remap(noise, 1.0f - layer.coverage, 1, 0, 1) * layer.opacity;
}

float blendNoise(float totalNoise, float noise, int blend) {
	float newNoise = 0;
	
	switch (blend) {
	case 0:
		newNoise = totalNoise + noise;
		break;
	case 1:
		newNoise = totalNoise - noise;
		break;
	case 2:
		newNoise = totalNoise * noise;
		break;
	case 3:
		if(noise != 0)
			newNoise = totalNoise / noise;
		break;
	default:
		newNoise = totalNoise + noise;
		break;
	}
	
	return newNoise;
}

void GenerateNoise2D(uint thread_x = 4, uint thread_y = 4, uint thread_z = 1) {
	uvec3 id = gl_GlobalInvocationID;

	if(any(greaterThanEqual(id.xy, _TexSize.xy)))
		return;

	vec3 point = vec3(id.x, id.y, 1);
	float noise = Value(point, _Layer);

	vec4 data = imageLoad(_NoiseTex2D, ivec2(id.xy));
	data.w = 1;

	switch (_ChannelIndex) {
		case 0:
			data.x = noise;
			break;
		case 1:
			data.y = noise;
			break;
		case 2:
			data.z = noise;
			break;
		case 3:
			data.w = noise;
			break;
	}

	imageStore(_NoiseTex2D, ivec2(id.xy), data);
}

void GenerateNoise3D(uint thread_x = 4, uint thread_y = 4, uint thread_z = 4) {
	uvec3 id = gl_GlobalInvocationID;

	if(any(greaterThanEqual(id, _TexSize)))
		return;

	vec3 point = vec3(id.x, id.y, id.z);
	float noise = Value(point, _Layer);

	vec4 data = imageLoad(_NoiseTex3D, ivec3(id.xyz));

	switch (_ChannelIndex) {
		case 0:
			data.x = noise;
			break;
		case 1:
			data.y = noise;
			break;
		case 2:
			data.z = noise;
			break;
		case 3:
			data.w = noise;
			break;
	}

	imageStore(_NoiseTex3D, ivec3(id.xyz), data);
}

void GenerateNoise2DMultiLayer(uint thread_x = 4, uint thread_y = 4, uint thread_z = 1) {
	
	uvec3 id = gl_GlobalInvocationID;

	if(any(greaterThanEqual(id.xy, _TexSize.xy)))
		return;

	vec3 point = vec3(id.x, id.y, 1);

	float totalNoise = 0;

	for(int i = 0; i < _LayerCount; i++) {
		float noise = Value(point, _Layers[i]);
	
		totalNoise = blendNoise(totalNoise, noise, _Layers[i].blend);
	}

	vec4 data = imageLoad(_NoiseTex2D, ivec2(id.xy));
	data.w = 1;

	switch (_ChannelIndex) {
		case 0:
			data.x = totalNoise;
			break;
		case 1:
			data.y = totalNoise;
			break;
		case 2:
			data.z = totalNoise;
			break;
		case 3:
			data.w = totalNoise;
			break;
	}

	imageStore(_NoiseTex2D, ivec2(id.xy), data);
}

void GenerateNoise3DMultiLayer(uint thread_x = 4, uint thread_y = 4, uint thread_z = 4) {
	
	uvec3 id = gl_GlobalInvocationID;

	if(any(greaterThanEqual(id, _TexSize)))
		return;
		
	vec3 point = vec3(id);
	float totalNoise = 0;

	for(int i = 0; i < _LayerCount; i++) {
		float noise = Value(point, _Layers[i]);
	
		totalNoise = blendNoise(totalNoise, noise, _Layers[i].blend);
	}

	vec4 data = imageLoad(_NoiseTex3D, ivec3(id));
	
	switch (_ChannelIndex) {
		case 0:
			data.x = totalNoise;
			break;
		case 1:
			data.y = totalNoise;
			break;
		case 2:
			data.z = totalNoise;
			break;
		case 3:
			data.w = totalNoise;
			break;
	}

	imageStore(_NoiseTex3D, ivec3(id), data);
}